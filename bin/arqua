#!/opt/local/bin/perl -W -t
use strict;
use List::Util qw[min max];
use Getopt::Long;

sub initPackage {
	my ($packageName, $parent) = @_;
	return {
		name => $packageName,
		parent => $parent,
		tangle => 0,
		complexity => 0,
		edges => 0,
		deps => {},
		functions => {},
		size => 0,
		nodes => {},
		depfuncs => {},
		circ => {},
		totSize => 0,
		totSmells => 0,
		tangleSmells => 0,
		complexitySmells => 0,
		level => 1,
		lowLevel => 0
	};
}

sub initFunction {
	my ($functionName, $parent) = @_;
	return {
		name => $functionName,
		functions => {$functionName => 1},
		parent => $parent,
		complexity => 0,
		size => 0,
		totSize => 0,
		totSmells => 0,
		deps => {},
		circ => {},
		depfuncs => {},
		tangleSmells => 0,
		complexitySmells => 0,
		level => 0
	};
}

sub initSmell {
	my ($name, $type, $value) = @_;
	return {
		"name" => $name,
		"type" => $type,
		"value" => $value
	};
}

sub calculateQuality {
	my ($size, $smells) = @_;
	return $size > 0 ? 100-$smells/$size*100 : 100;
}

sub calculateComplexity {
	my ($value, $tolerance) = @_;
	return $value > 0 ? max(0, ($value - $tolerance)/$value) : 0;
}

sub calculateTangle {
	my ($tangles, $edges) = @_;
	return $edges > 0 ? $tangles/$edges*2 : 0;
}

sub parseExpandLineFunction {
	my ($parent, $line, $currentFunction) = @_;
	my $nodes = $parent->{nodes};
	if ($line =~ /^;; Function (.*)\s+\((\S+)(,.*)?\)\s*$/) {
		my $functionName = $2;
		unless (exists($nodes->{$functionName})) {
			$nodes->{$functionName} = initFunction($functionName, $parent);
		}
		return $functionName;
	} elsif ($currentFunction ne "") {
		if (exists($nodes->{$currentFunction})) {
			if ($line =~ /^.*\(call.*"(.*)".*$/) {
				unless (exists($nodes->{$currentFunction}->{depfuncs}->{$1})) {
					$nodes->{$currentFunction}->{depfuncs}->{$1} = 0;
				}
				$nodes->{$currentFunction}->{depfuncs}->{$1} += 1;
			} elsif ($line =~ /^.*\(symbol_ref.*"(.*)".*$/) {
				unless (exists($nodes->{$currentFunction}->{depfuncs}->{$1})) {
					$nodes->{$currentFunction}->{depfuncs}->{$1} = 0;
				}
				$nodes->{$currentFunction}->{depfuncs}->{$1} += 1;
			}
			if ($line =~ /^.*\(if_then_else.*$/) {
				$nodes->{$currentFunction}->{complexity} += 1;
			}
			if ($line =~ /^.*\(insn.*/) {
				$nodes->{$currentFunction}->{size} += 1;
				$nodes->{$currentFunction}->{totSize} += 1;
			}
		}
	}
	return $currentFunction;
}

sub parseExpandLinePackage {
	my ($package, $path, $line, $currentFunction) = @_;
	if ($path) {
		my ($subPackageName, $remainingPath) = split(/\//, $path, 2);
		unless (exists($package->{nodes}->{$subPackageName})) {
			$package->{nodes}->{$subPackageName} = initPackage($subPackageName, $package);
		}
		return parseExpandLinePackage($package->{nodes}->{$subPackageName}, $remainingPath, $line, $currentFunction);
	}
	return parseExpandLineFunction($package, $line, $currentFunction);
}

sub calculatePackage {
	my ($package, $functionTolerance, $tolerance) = @_;
	foreach my $child (values %{$package->{nodes}}) {
		calculateNode($child, $functionTolerance, $tolerance);
		foreach my $function (keys %{$child->{functions}}) {
			$package->{functions}->{$function} = 1;
		}
		$package->{size} += $child->{size};
		$package->{totSmells} += $child->{totSmells};
		if ($child->{level} + 1 >= $package->{level}) {
			$package->{level} = $child->{level} + 1;
		}
		if ($child->{level} + 1 < $package->{lowLevel} or $package->{lowLevel} == 0) {
			$package->{lowLevel} = $child->{level} + 1;
		}
	}
	$package->{totSize} = $package->{size}*2;
	foreach my $callernode (values %{$package->{nodes}}) {
		 while (my ($calleefunc, $calleefuncnbr) = each(%{$callernode->{depfuncs}})) {
			my $calleefound = 0;
			while (my ($calleenodename, $calleenode) = each(%{$package->{nodes}})) {
				if (exists($calleenode->{functions}->{$calleefunc})) {
					unless (exists($callernode->{deps}->{$calleenodename})) {
						$callernode->{deps}->{$calleenodename} = 0;
						$package->{complexity} += 1;
					}
					$callernode->{deps}->{$calleenodename} += $calleefuncnbr;
					$package->{edges} += $calleefuncnbr;
					$calleefound = 1;
				}
			}
			unless ($calleefound) {
				unless (exists($package->{depfuncs}->{$calleefunc})) {
					$package->{depfuncs}->{$calleefunc} = 0;
				}
				$package->{depfuncs}->{$calleefunc} += $calleefuncnbr;
			}
		}
	}
	my $tmpTangle = 0;
	while (my ($callername, $caller) = each(%{$package->{nodes}})) {
		while (my ($calleename, $callee) = each(%{$caller->{deps}})) {
			if (exists($caller->{deps}->{$calleename}) and
				exists($package->{nodes}->{$calleename}->{deps}->{$callername})) {
				my $callernbr = $callee;
				my $calleenbr = $package->{nodes}->{$calleename}->{deps}->{$callername};
				if ($callernbr > $calleenbr) {
					if (exists($package->{nodes}->{$calleename})) {
						$package->{nodes}->{$calleename}->{circ}->{$callername} = 1;
					}
				} elsif ($callernbr < $calleenbr) {
					$caller->{circ}->{$calleename} = 1;
				} else {
					$caller->{circ}->{$calleename} = 1;
					if (exists($package->{nodes}->{$calleename})) {
						$package->{nodes}->{$calleename}->{circ}->{$callername} = 1;
					}
				}
				$tmpTangle += min($callernbr, $calleenbr);
			}
		}
	}
	$package->{tangle} = $tmpTangle/2;
	$package->{calculatedTangle} = calculateTangle($package->{tangle}, $package->{edges});
	$package->{calculatedComplexity} = calculateComplexity($package->{complexity}, $tolerance);
	$package->{tangleSmells} = $package->{size}*$package->{calculatedTangle};
	$package->{complexitySmells} = $package->{size}*$package->{calculatedComplexity};
	$package->{totSmells} += $package->{complexitySmells};
	$package->{totSmells} += $package->{tangleSmells};
}

sub calculateFunction {
	my ($function, $tolerance) = @_;
	$function->{calculatedComplexity} = calculateComplexity($function->{complexity}, $tolerance);
	$function->{complexitySmells} = $function->{size}*$function->{calculatedComplexity};
	$function->{totSmells} = $function->{complexitySmells};
	$function->{level} = 0;
}

sub calculateNode {
	my ($node, $functionTolerance, $packageTolerance) = @_;
	my $calculator = exists($node->{nodes}) ? \&calculatePackage : \&calculateFunction;
	$calculator->($node, $functionTolerance, $packageTolerance);
}

sub extractPackageSmells {
	my ($parent, $package, $smells) = @_;
	if (exists($package->{name})) {
		my $name = $parent . "/" . $package->{name};
		push (@{$smells}, initSmell($name, "Tangle", $package->{tangleSmells}));
		push (@{$smells}, initSmell($name, "Complexity", $package->{complexitySmells}));
		if (exists($package->{nodes})) {
			foreach my $node (values %{$package->{nodes}}) {
				extractPackageSmells($name, $node, $smells);
			}
		}
	}
}

sub createSortedSmellsList {
	my ($package) = @_;
	my $smells = [];
	extractPackageSmells("", $package, $smells);
	return [sort {$b->{value} <=> $a->{value}} @{$smells}];
}

sub drawFunctionList {
	my ($package) = @_;
	my $graph = "";
	my $report = "";
	if ($package->{calculatedComplexity} > 0) {
		my $functionComplexityString = sprintf("%.0f", $package->{calculatedComplexity}*100);
		my $xsString = sprintf("%.0f", $package->{complexitySmells});
		$report .= " C=" . $functionComplexityString . "%";
		$report .= ", CS=" . $xsString;
	}
	$graph .= $package->{name} . "()" . $report . "\\n";
	return $graph;
}


sub drawLeafPackageGraph {
	my ($package, $prefix, $functionDrawer, $start, $reportLabel, $fontColor) = @_;
	my $graph = "PKG_" . $prefix . $package->{name};
	$graph .= " [" . $fontColor . ", label=\"{" . $package->{name} . "|" . $reportLabel . "|";
	if ($package->{level} == 1) {
		foreach my $subPackage (values %{$package->{nodes}}) {
			$graph .= $functionDrawer->($subPackage, $prefix);
		}
	}
	$graph .= "}\", shape=record, style=filled";
	$graph .= "];\n";
	foreach my $callee (keys %{$package->{deps}}) {
		my $calleename = $prefix;
		if ($package->{parent}->{nodes}->{$callee}->{level} >= $start) {
			$calleename .= $callee;
		}
		$graph .= "PKG_" . $prefix . $package->{name} . "->PKG_" . $calleename;
		$graph .= "[label=" . $package->{deps}->{$callee};
		if ($package->{parent}->{nodes}->{$callee}->{level} > $start) {
			$graph .= ", lhead=cluster_" . $prefix . $callee;
		}
		if (exists($package->{circ}->{$callee})) {
			$graph .= ", color=crimson, fontcolor=crimson, style=bold";
		}
		$graph .= "];\n";
	}
	return $graph;
}

sub drawNodePackageGraph {
	my ($package, $prefix, $functionDrawer, $start, $stop, $root, $packagePath, $reportLabel, $fontColor) = @_;
	my $graph = "";
	my $subGraph = join("", map(
		{ drawGraph($_, $packagePath, $functionDrawer, $start, $stop, $root);
	} values %{$package->{nodes}}));
	unless (index($packagePath, $root) eq 0 and ($package->{level} <= $stop or $stop eq 0)) {
		return $subGraph;
	}
	$graph = "subgraph cluster_" . $packagePath . " {\n";
	$graph .= $fontColor . ";label=\"" . $package->{name} . "\\n" . $reportLabel . "\";\n";
	if ($package->{parent}->{lowLevel} == $package->{parent}->{level}) {
		$graph .= "PKG_" . $packagePath . " [label=\"" . $package->{parent}->{lowLevel} . " " . $package->{parent}->{level}  . "\", style=invisible];\n";
	} else {
		$graph .= "PKG_" . $prefix . $package->{name};
		$graph .= " [" . $fontColor . ", label=\"{" . $package->{name} .  " (self)" . "|" . $reportLabel . "|";
		if ($package->{level} == 1) {
			foreach my $subPackage (values %{$package->{nodes}}) {
				$graph .= $functionDrawer->($subPackage, $prefix);
			}
		}
		$graph .= "}\", shape=record, style=filled";
		$graph .= "];\n";
	}
	$graph .= $subGraph;
	$graph .= "}\n";
	foreach my $callee (keys %{$package->{deps}}) {
		my $calleename = $prefix;
		if ($package->{parent}->{nodes}->{$callee}->{level} >= $start) {
			$calleename .= $callee;
		}
		$graph .= "PKG_" . $packagePath . "->PKG_" . $calleename;
		$graph .= " [ltail=cluster_" . $packagePath;
		if ($package->{parent}->{nodes}->{$callee}->{level} > $start) {
			$graph .= ", lhead=cluster_" . $prefix . $callee;
		}
		$graph .= ", label=" . $package->{deps}->{$callee};
		if (exists($package->{circ}->{$callee})) {
			$graph .= ", color=crimson, fontcolor=crimson, style=bold";
		}
		$graph .= "];\n";
	}
	return $graph;
}

sub drawPackageGraph {
	my ($package, $prefix, $functionDrawer, $start, $stop, $root) = @_;
	my $graph = "";
	my $reportLabel = "";
	my $fontColor = "fontcolor=black";

	if ($package->{level} < $start) {
		return "";
	}

	if ($package->{complexitySmells} > 0) {
		my $packageComplexityString = sprintf("%.0f", $package->{calculatedComplexity}*100);
		my $cxsString = sprintf("%.0f", $package->{complexitySmells});
		$reportLabel .= "C=" . $packageComplexityString . "%";
		$reportLabel .= ", CS=" . $cxsString;
	}

	if ($package->{tangleSmells} > 0) {
		my $packageTangleString = sprintf("%.0f", $package->{calculatedTangle}*100);
		my $txsString = sprintf("%.0f", $package->{tangleSmells});
		$reportLabel .= " T=" . $packageTangleString . "%";
		$reportLabel .= ", TS=" . $txsString;
	}

	if ($package->{tangleSmells} > 0 or $package->{complexitySmells} > 0) {
		$fontColor = "fontcolor=crimson";
	}

	my $packagePath = $prefix . $package->{name};

	if ($package->{level} > $start) {
		$graph .= drawNodePackageGraph(
			$package, $prefix, $functionDrawer, $start, $stop,
			$root, $packagePath, $reportLabel, $fontColor);
	}

	if ($package->{level} == $start and
		index($packagePath, $root) eq 0 and
		($package->{level} <= $stop or $stop eq 0)) {
		$graph .= drawLeafPackageGraph(
			$package, $prefix, $functionDrawer, $start, $reportLabel, $fontColor);
	}
	return $graph;
}

sub drawFunctionGraph {
	my ($package, $prefix) = @_;
	my $graph = "";
	foreach (keys %{$package->{functions}}) {
		my $functionComplexityString = sprintf("%.0f", $package->{calculatedComplexity}*100);
		my $xsString = sprintf("%.0f", $package->{complexitySmells});
		$graph .= $prefix . $package->{name} . " [style=filled, label=\"" . $package->{name};
		if ($package->{complexitySmells} > 0) {
			$graph .= "\\nC=" . $functionComplexityString . "%";
			$graph .= ", CS=" . $xsString;
			$graph .= "\", fontcolor=black, color=crimson";
		} else {
			$graph .= "\", color=grey, fontcolor=black";
		}
		$graph .= "];\n";
	}

	while (my ($calleename, $callee) = each(%{$package->{deps}})) {
		$graph .= $prefix . $package->{name} . "->" . $prefix . $calleename;
		$graph .= " [label=" . $callee;
		$graph .= exists($package->{circ}->{$calleename}) ? ", color=crimson, fontcolor=crimson, style=bold" : "";
		$graph .= "];\n";
	}
	return $graph;
}

sub drawGraph {
	my ($package, $prefix, $functionDrawer, $start, $stop, $root) = @_;
	my $graphCreator = exists($package->{nodes}) ?  \&drawPackageGraph : $functionDrawer;
	return $graphCreator->($package, $prefix, $functionDrawer, $start, $stop, $root);
}

sub drawEmpty {
	return "";
}

sub createSystemGraphReport {
	my ($node, $functionDrawer, $start, $stop, $root) = @_;
	my $graph = "digraph system {\ncompound=true;\n";
	my $quality = calculateQuality($node->{totSize}, $node->{totSmells});
	$graph .= "labelloc=t;\nlabel=\"Total Smells:" . sprintf("%.0f", $node->{totSmells});
	$graph .= ", Quality:" .  sprintf("%.0f", $quality) . "%\\n";
	my $smells = createSortedSmellsList($node);
	my $index = 0;
	my $report = "";
	for (my $i = 0; $i < 5 && $i < @{$smells}; $i++) {
		my $smell = @{$smells}[$i];
		$report .= $smell->{value} > 0 ? $smell->{name} . ": " . $smell->{type} . " Smells:" . sprintf("%.0f", $smell->{value}) . "\\n" : "";
	}
	$graph .= $report . "\";\n";
	$graph .= drawGraph($node, "", $functionDrawer, $start, $stop, $root);
	$graph .= "}\n";
	return $graph;
}

sub createSystemTextReport {
	my ($node) = @_;
	my $quality = calculateQuality($node->{totSize}, $node->{totSmells});
	my $report = "Arqua Report:\n";
	$report .= "----------------------------------------\n";
	$report .= "Total Smells:" . sprintf("%.0f", $node->{totSmells}) . "\n";
	$report .= "Quality:" .  sprintf("%.0f", $quality) . "%\n";
	$report .= "----------------------------------------\n";
	$report .= "Top Smells:\n";
	$report .= "----------------------------------------\n";
	my $smells = createSortedSmellsList($node);
	$report .= join("", map({
		$_->{value} > 0 ? $_->{name} . ": " . $_->{type} . " Smells:" . sprintf("%.0f", $_->{value}) . "\n" : "";
	} values @{$smells}));
	return $report;
}

sub main() {
	my $reportType = "graph";
	my $packageTolerance = 35;
	my $functionTolerance = 5;
	my $showFunctions = 0;
	my $root = "";
	my $start = 1;
	my $stop = 0;
	my $functionDrawer = \&drawEmpty;
	my $report = {
		graph => \&createSystemGraphReport,
		text => \&createSystemTextReport
	};

	GetOptions(
		"start=i" => \$start,
		"stop=i" => \$stop,
		"root=s" => \$root,
		"functions" => \$showFunctions,
		"pt=i" => \$packageTolerance,
		"ft=i" => \$functionTolerance,
		"report=s" => \$reportType);

	$root =~ s/\///g;
	$root =~ s/-/_/g;

	my $package = initPackage("");
	my $function = "";

	if ($start < 1) {
		$functionDrawer = \&drawFunctionGraph;
	} elsif ($showFunctions) {
		$functionDrawer = \&drawFunctionList;
	}

	while (<>) {
		my ($filePath) = split(/\./, $ARGV);
		$filePath =~ s/-/_/g;
		$function = parseExpandLinePackage($package, $filePath, $_, $function);
	}
	calculateNode($package, $functionTolerance, $packageTolerance);
	print $report->{$reportType}($package, $functionDrawer, $start, $stop, $root);
}

main();
